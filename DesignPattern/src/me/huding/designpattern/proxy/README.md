
#代理模式：

代理模式，也叫委托模式，是一个使用率非常高的模式。

代理模式，为其他对象提供一种代理以控制对这个对象的访问。

#代理模式提供以下3个角色：

1.抽象主题角色：该角色是真实主题和代理主题的共同接口，以便在任何可以使用真实主题的地方都可以使用代理主题。

2.代理主题角色：该角色负责对真实主题的引用，负责在需要的时候创建和删除真实主题对象，并且在真实主题角色处理完毕前后做预处理和善后处理工作。

3.真实主题角色：是业务逻辑的具体执行者。



一个代理主题类可以代理多个真实主题，具体代理哪个真实主题是由高层的应用模块决定的，可以通过代理类的构造函数传递被代理者。


#代理模式的优点：

1.职责清晰：真实的角色实现实际的业务逻辑，不用关心其他非本职的事务，通过后期的代理完成附加的事务，附带的结果就是编程简洁清晰。

2.高扩展性：具体主题角色随需求不同可能有很多种，但只要实现了接口，代理类就完全可以在不做任何修改的情况下代理各种真实主题角色。

3.智能化：代理类可以在运行时才确定需要去代理的真实主题，这是一个强大的功能。


#代理模式的使用场景：

代理模式应用非常广泛，大到一个系统框架，企业平台，小到事务处理，代码片段，随处可见代理模式的使用，例如：Java RMI的远程调用就是一种代理模式的应用，现在流行的AOP也可以通过代理模式实现。


# 装饰器模式与代理模式的区别

从功能效果上看
　　装饰模式：在不改变接口的前提下，动态扩展对象的功能

　　代理模式：在不改变接口的前提下，控制对象的访问

　　装饰模式强调功能扩展，比如A对象的B方法，运用装饰模式后，在调用B方法前后，实现新的功能，此时B方法效果与原来不同

　　代理模式强调控制访问，如上例，运用代理模式后，在调用B方法前后，控制怎么访问B方法的原始数据，而对于B实现的功能效果不做修改

　　因此，如果运用设计模式后，方法的功能效果（主要是输出效果）不变，一般可视为代理。

　从类结构上看
　　通过装饰模式结构图中可以看出

![](9297010439.gif)

Component类在Decorator模式中充当抽象接口的角色，不应该去实现具体的行为。而且Decorator类对于Component类应该透明，换言之Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能。
　　Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系


同样，通过代理模式结构图中可以得出


![](9298010439.gif)

代理类和被代理对象是has-a关系，一般没有is-a关系，除非代理类直接继承被代理类，重写被代理类的方法，即上图中没有抽象Subject类时的情况。


参考资料：1.[http://www.educity.cn/wenda/363782.html](http://www.educity.cn/wenda/363782.html)
